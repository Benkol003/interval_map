<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="referrer" content="origin" />

		<meta name="google-site-verification" content="-NNcvD_gJzqSp-HBpUgQS_t5ALaPcwj46r2FdsoRcQk" />
		<meta name="msvalidate.01" content="D31802FCEB4B1836C8DEC8F066A21FC0" />
		<meta name="y_key" content="2d56ae64a47b4e0d" />

		<link href="/portal/favicon.ico" rel="shortcut icon" />
		<link href="/portal/images/logo_thinkcell_57.png" rel="apple-touch-icon" />
		<link href="/portal/images/logo_thinkcell_72.png" rel="apple-touch-icon" sizes="72x72" />
		<link href="/portal/images/logo_thinkcell_114.png" rel="apple-touch-icon" sizes="114x114" />
		<link href="/portal/images/logo_thinkcell_144.png" rel="apple-touch-icon" sizes="144x144" />

		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
		<link href="https://www.think-cell.com/css/site.css?id=a54b0c0b4f4a17164cb0dd367dfcc622" rel="stylesheet" />
		<script src="https://www.think-cell.com/js/site-config.js?id=1a56e17bcf698ba50676c66f22ca340c"></script>

		<meta property="og:type" content="website" />
<title>Recruiting test | think-cell</title><meta property="og:title" content="Recruiting test | think-cell" /><meta name="description" content="Recruiting test" /><meta property="og:description" content="Recruiting test" /><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-T6MPKXF');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T6MPKXF" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="navbar-group"><nav class="navbar navbar-expand-lg navbar-upper"><div class="container-fluid"><a class="navbar-brand mr-auto" href="https://server.think-cell.com/portal/en/redirect.srf?url=https%3A%2F%2Fwww.think-cell.com%2Fen%2F"><div class="navbar-logo"></div></a></div></nav></div><main>

<div class="heading heading--margin-bottom">
	<h1>
									Recruiting test
						</h1>
</div>

<div class="section container-fluid">
	<form action="#CompilationResult" method="post" accept-charset="UTF-8">
		<div class="row">
			<div class="col-lg-9">
				
							
					
									 						<h2>Test assignment</h2>
						<p>
							Thank you for participating in our recruiting test.
																																																									This will be a C++ programming test!
																				</p>
																																	<div class="panel-group">
									<div class="panel">
										<div class="panel-heading collapsed" data-toggle="collapse" data-target="#howtoprepare">
											<h3 class="panel-title">
																			How to prepare for this test
											</h3>
																	</div>
										<div id="howtoprepare" class="panel-body collapse">
																									<p>
												Install an editor and C++ compiler of your choice. Your solution will be compiled with GCC 7.2.0 (with <code>-std=c++17</code>), 
												and you will have the chance to fix any compilation errors prior to submission.
												You may use the standard libraries for the task. It is not permitted to use other libraries, however you will not need them anyway.
											</p>
											<p>
												You are free in your choice of operating system and development environment. 
												The task is a very general programming assignment testing general problem structuring and programming proficiency. 
												The solution has to be submitted within a 9 hour time frame. Excellent C++ specialists often solve the problem in 
												<strong>3 to 4 hours</strong>, and we leave it to the candidates to test their solutions thoroughly before handing them in (in case they finish early).
											</p>
											<p>
												You must develop the solution yourself. You may not let others help you or search for existing solutions. Of course,
												you may use any documentation of the C++ language or the C++ Standard Library. Do not give your solution to others or make it public.
												It may entice others to send in plagiarized solutions, and thus make our recruiting less fair. If you use an online compiler, make sure that the privacy settings are set to private.
												Publishing the task description is also considered cheating and will void your application.
											</p>
											<p>
												The amount of code you need for a correct solution is relatively small, and you will spend most of the allocated time thinking rather than typing.
												We would like to receive the best solution you can come up with!
											</p>
																								</div>
									</div>
								</div>
																																		<h3>Task Description</h3>
								<p>
									<code>interval_map&lt;K,V&gt;</code> is a data structure that associates keys of type <var>K</var> with values of type <var>V</var>.
									It is designed to be used efficiently in situations where intervals of consecutive keys are associated with the same value.
									Your task is to implement the <code>assign</code> member function of this data structure, which is outlined below. 
								</p>
								<p>
									<code>interval_map&lt;K, V&gt;</code> is implemented on top of <code>std::map</code>. For more information on
									<code>std::map</code>, you may refer to <a class="extlink" href="https://en.cppreference.com/w/cpp/container/map" target="_blank" rel="noopener">cppreference.com</a>.
								</p>
								<p>
									Each key-value-pair (<var>k</var>,<var>v</var>) in <code>interval_map&lt;K,V&gt;::m_map</code> means that the value <var>v</var> is associated with all keys from <var>k</var> (including) to
									the next key (excluding) in <code>m_map</code>. The member <code>interval_map&lt;K,V&gt;::m_valBegin</code> holds the value that is associated with all keys
									less than the first key in <code>m_map</code>.
								</p>
								<p>
									Example: Let <var>M</var> be an instance of <code>interval_map&lt;int,char&gt;</code> where
								</p>
								<ul class="indented list-unstyled">
									<li><code>M.m_valBegin=='A'</code>,</li>
									<li><code>M.m_map=={ (1,'B'), (3,'A') }</code>,</li>
								</ul>
								<p>
									Then <var>M</var> represents the mapping
								</p>
								<ul class="indented list-unstyled">
									<li>...</li>
									<li><code>-2 -&gt; 'A'</code></li>
									<li><code>-1 -&gt; 'A'</code></li>
									<li><code>0 -&gt; 'A'</code></li>
									<li><code>1 -&gt; 'B'</code></li>
									<li><code>2 -&gt; 'B'</code></li>
									<li><code>3 -&gt; 'A'</code></li>
									<li><code>4 -&gt; 'A'</code></li>
									<li><code>5 -&gt; 'A'</code></li>
									<li>...</li>
								</ul>
								<p>
									The representation in the <code>std::map</code> must be canonical, that is, consecutive map entries must not contain the same value: <code>..., (3,'A'), (5,'A'), ...</code> is not allowed.
									Likewise, the first entry in <code>m_map</code> must not contain the same value as <code>m_valBegin</code>.
									Initially, the whole range of <var>K</var> is associated with a given initial value, passed to the constructor of the <code>interval_map&lt;K,V&gt;</code> data structure.
								</p>
								<p><strong>Key type <var>K</var></strong></p>
								<ul>
									<li>besides being copyable and assignable, is less-than comparable via <code>operator&lt;</code>, and</li>
									<li>does not implement any other operations, in particular no equality comparison or arithmetic operators.</li>
								</ul>
								<p><strong>Value type <var>V</var></strong></p>
								<ul>
									<li>besides being copyable and assignable, is equality-comparable via <code>operator==</code>, and</li>
									<li>does not implement any other operations.</li>
								</ul>
							<h2>First Evaluation</h2><pre><code>#include &lt;map&gt;&#10;template&lt;typename K, typename V&gt;&#10;class interval_map {&#10;	friend void IntervalMapTest();&#10;	V m_valBegin;&#10;	std::map&lt;K,V&gt; m_map;&#10;public:&#10;	// constructor associates whole range of K with val&#10;	interval_map(V const&amp; val)&#10;	: m_valBegin(val)&#10;	{}&#10;&#10;	// Assign value val to interval [keyBegin, keyEnd).&#10;	// Overwrite previous values in this interval.&#10;	// Conforming to the C++ Standard Library conventions, the interval&#10;	// includes keyBegin, but excludes keyEnd.&#10;	// If !( keyBegin &lt; keyEnd ), this designates an empty interval,&#10;	// and assign must do nothing.&#10;	void assign( K const&amp; keyBegin, K const&amp; keyEnd, V const&amp; val ) {&#10;</code></pre><pre><code>        if(! (keyBegin&lt;keyEnd) ) return;&#10;        if(m_map.size()==0){&#10;            if(val!=m_valBegin){&#10;                m_map[keyBegin]=val;&#10;                m_map[keyEnd]=m_valBegin;&#10;            } else return;&#10;        }else{&#10;            //starting index&#10;            typename std::map&lt;K,V&gt;::iterator keyBeginNextRange = m_map.upper_bound(keyBegin);&#10;            V keyEndVal;&#10;            if(keyBeginNextRange == m_map.begin() ){&#10;                if(val!=m_valBegin) m_map[keyBegin]=val; //iterators arent invalidated by inserts&#10;                keyEndVal = m_valBegin;&#10;            }else{&#10;                typename std::map&lt;K,V&gt;::iterator keyBeginPrevRange = (--keyBeginNextRange)++;&#10;                //keyEndVal - is value for any ranges that extend past keyEnd&#10;                if(keyBeginPrevRange-&gt;first &lt; keyBegin){&#10;                    keyEndVal = keyBeginPrevRange-&gt;second;&#10;                    if(keyEndVal!=val) m_map[keyBegin]=val;&#10;                }else{ &#10;                    //now keyBeginPrevRange = keyBegin&#10;                     if(keyBeginPrevRange-&gt;second == val){&#10;                        keyEndVal = val; //value before keyBeginPrevRange has to be different to value after&#10;                     }else{&#10;                        keyEndVal = keyBeginPrevRange-&gt;second;&#10;                        V valuePrev;&#10;                        if(keyBeginPrevRange==m_map.begin()) valuePrev = m_valBegin;&#10;                        else{&#10;                            typename std::map&lt;K,V&gt;::iterator actualPrev = (--keyBeginPrevRange)++;&#10;                            valuePrev = actualPrev-&gt;second; &#10;                        }&#10;                        if(valuePrev==val){&#10;                            m_map.erase(keyBeginPrevRange);&#10;                             &#10;                        }else{&#10;                            //reuse iterator rather than look up again&#10;                            keyBeginPrevRange-&gt;second=val;&#10;                        }&#10;                     }&#10;                }&#10;&#10;            }&#10;&#10;            //walk upto keyEnd&#10;            while(keyBeginNextRange != m_map.end() &amp;&amp; keyBeginNextRange-&gt;first&lt;keyEnd){&#10;                typename std::map&lt;K,V&gt;::iterator erase_i = keyBeginNextRange;&#10;                keyEndVal=keyBeginNextRange-&gt;second;&#10;                ++keyBeginNextRange;&#10;                m_map.erase(erase_i);&#10;            }&#10;            &#10;            //at this point keyBeginNextRange might aswell be keyBeginEndRange&#10;            typename std::map&lt;K,V&gt;::iterator keyEndNextRange = keyBeginNextRange; //readability, also garunteed keyEndNextRange &gt;=keyEnd&#10;            if(keyEndNextRange == m_map.end()){&#10;                if(keyEndVal!=val) m_map[keyEnd]=keyEndVal;&#10;            }else{&#10;                if(keyEnd&lt;keyEndNextRange-&gt;first){&#10;                    if(keyEndVal!=val) m_map[keyEnd]=keyEndVal;&#10;                }else{//keyEndNextRange and keyEnd equal, also therefore no keyEndVal&#10;                    if(val==keyEndNextRange-&gt;second) m_map.erase(keyEndNextRange);&#10;                }&#10;            }&#10;        }</code></pre><pre><code>&#10;	}&#10;&#10;	// look-up of the value associated with key&#10;	V const&amp; operator[]( K const&amp; key ) const {&#10;		auto it=m_map.upper_bound(key);&#10;		if(it==m_map.begin()) {&#10;			return m_valBegin;&#10;		} else {&#10;			return (--it)-&gt;second;&#10;		}&#10;	}&#10;};&#10;&#10;// Many solutions we receive are incorrect. Consider using a randomized test&#10;// to discover the cases that your implementation does not handle correctly.&#10;// We recommend to implement a test function that tests the functionality of&#10;// the interval_map, for example using a map of int intervals to char.</code></pre><p>Unfortunately, this program failed to meet the criterion marked in red:<p><ul class="list-custom"><li class="icon-error alert-danger"><strong>Type requirements are met:</strong> You must adhere to the specification of the key and value type given above. </li><li class="icon-dot"><strong>Correctness:</strong> Your program should produce a working <code>interval_map</code> with the behavior described above. In particular, pay attention to the validity of iterators. It is illegal to dereference end iterators. Consider using a checking STL implementation such as the one shipped with Visual C++ or GCC. </li><li class="icon-dot"><strong>Canonicity:</strong> The representation in <code>m_map</code> must be canonical. </li><li class="icon-dot"><p><strong>Running time:</strong> Imagine your implementation is part of a library, so it should be big-O optimal. In addition:</p><ul><li>Do not make big-O more operations on <var>K</var> and <var>V</var> than necessary because you do not know how fast operations on <var>K</var>/<var>V</var> are; remember that constructions, destructions and assignments are operations as well.</li><li>Do not make more than one operation of amortized O(log <var>N</var>), in contrast to O(1), running time, where <var>N</var> is the number of elements in <code>m_map</code>. Overloads of std::map::insert&sol;emplace&sol;delete that need to find an element position for a given key, have a running time of amortized O(log <var>N</var>). Overloads of std::map::insert&sol;emplace&sol;delete that take an iterator to the position of the inserted&sol;deleted element,have a running time of amortized O(1), if the iterator points to the correct position.</li><li>Otherwise favor simplicity over minor speed improvements.</li></ul></li></ul><hr /><h2>Second Chance</h2><p>Your first try failed. But we give you one more chance to fix your code:<p><h2>Final Evaluation</h2><pre><code>#include &lt;map&gt;&#10;template&lt;typename K, typename V&gt;&#10;class interval_map {&#10;	friend void IntervalMapTest();&#10;	V m_valBegin;&#10;	std::map&lt;K,V&gt; m_map;&#10;public:&#10;	// constructor associates whole range of K with val&#10;	interval_map(V const&amp; val)&#10;	: m_valBegin(val)&#10;	{}&#10;&#10;	// Assign value val to interval [keyBegin, keyEnd).&#10;	// Overwrite previous values in this interval.&#10;	// Conforming to the C++ Standard Library conventions, the interval&#10;	// includes keyBegin, but excludes keyEnd.&#10;	// If !( keyBegin &lt; keyEnd ), this designates an empty interval,&#10;	// and assign must do nothing.&#10;	void assign( K const&amp; keyBegin, K const&amp; keyEnd, V const&amp; val ) {&#10;</code></pre><pre><code>        if(! (keyBegin&lt;keyEnd) ) return;&#10;        if(m_map.size()==0){&#10;            if(!(val==m_valBegin)){&#10;                m_map.emplace(keyBegin,val);&#10;                m_map.emplace(keyEnd,m_valBegin);&#10;            } else return;&#10;        }else{&#10;            //starting index&#10;            typename std::map&lt;K,V&gt;::iterator keyBeginNextRange = m_map.upper_bound(keyBegin);&#10;            V* keyEndVal(nullptr); //wasnt sure if no-arg constructor was available - c++ will initialise local class instances. would be nice if i could use std::unique_ptr&#10;            if(keyBeginNextRange == m_map.begin() ){&#10;                if(!(val==m_valBegin)) m_map.emplace(keyBegin,val);//iterators arent invalidated by inserts&#10;                delete keyEndVal;&#10;                keyEndVal = new V(m_valBegin);&#10;            }else{&#10;                typename std::map&lt;K,V&gt;::iterator keyBeginPrevRange = (--keyBeginNextRange)++;&#10;                //keyEndVal - is value for any ranges that extend past keyEnd&#10;                if(keyBeginPrevRange-&gt;first &lt; keyBegin){&#10;                    delete keyEndVal;&#10;                    keyEndVal = new V(keyBeginPrevRange-&gt;second);&#10;                    if(!(*keyEndVal==val)) m_map.emplace(keyBegin,val);&#10;                }else{ &#10;                    //now keyBeginPrevRange = keyBegin&#10;                     if(keyBeginPrevRange-&gt;second == val){&#10;                        delete keyEndVal;&#10;                        keyEndVal = new V(val); //value before keyBeginPrevRange has to be different to value after&#10;                     }else{&#10;                        delete keyEndVal;&#10;                        keyEndVal = new V(keyBeginPrevRange-&gt;second);&#10;                        V* valuePrev = nullptr;&#10;                        if(keyBeginPrevRange==m_map.begin()){&#10;                            delete valuePrev;&#10;                            valuePrev = new V(m_valBegin);&#10;                        }&#10;                        else{&#10;                            typename std::map&lt;K,V&gt;::iterator actualPrev = (--keyBeginPrevRange)++;&#10;                            delete valuePrev;&#10;                            valuePrev = new V(actualPrev-&gt;second); &#10;                        }&#10;                        if(*valuePrev==val){&#10;                            m_map.erase(keyBeginPrevRange);&#10;                             &#10;                        }else{&#10;                            //reuse iterator rather than look up again&#10;                            keyBeginPrevRange-&gt;second=val;&#10;                        }&#10;                     }&#10;                }&#10;&#10;            }&#10;&#10;            //walk upto keyEnd&#10;            while(keyBeginNextRange != m_map.end() &amp;&amp; keyBeginNextRange-&gt;first&lt;keyEnd){&#10;                typename std::map&lt;K,V&gt;::iterator erase_i = keyBeginNextRange;&#10;                delete keyEndVal;&#10;                keyEndVal=new V(keyBeginNextRange-&gt;second);&#10;                ++keyBeginNextRange;&#10;                m_map.erase(erase_i);&#10;            }&#10;            &#10;            //at this point keyBeginNextRange might aswell be keyBeginEndRange&#10;            typename std::map&lt;K,V&gt;::iterator keyEndNextRange = keyBeginNextRange; //readability, also garunteed keyEndNextRange &gt;=keyEnd&#10;            if(keyEndNextRange == m_map.end()){&#10;                if(!(*keyEndVal==val)) m_map.emplace(keyEnd,*keyEndVal);&#10;            }else{&#10;                if(keyEnd&lt;keyEndNextRange-&gt;first){&#10;                    if(!(*keyEndVal==val)) m_map.emplace(keyEnd,*keyEndVal);&#10;                }else{//keyEndNextRange and keyEnd equal, also therefore no keyEndVal&#10;                    if(val==keyEndNextRange-&gt;second) m_map.erase(keyEndNextRange);&#10;                }&#10;            }&#10;        }</code></pre><pre><code>&#10;	}&#10;&#10;	// look-up of the value associated with key&#10;	V const&amp; operator[]( K const&amp; key ) const {&#10;		auto it=m_map.upper_bound(key);&#10;		if(it==m_map.begin()) {&#10;			return m_valBegin;&#10;		} else {&#10;			return (--it)-&gt;second;&#10;		}&#10;	}&#10;};&#10;&#10;// Many solutions we receive are incorrect. Consider using a randomized test&#10;// to discover the cases that your implementation does not handle correctly.&#10;// We recommend to implement a test function that tests the functionality of&#10;// the interval_map, for example using a map of int intervals to char.</code></pre><a name="Feedback"></a><p><strong>Unfortunately, this program also did not pass.</strong></p><p>This time, it failed to meet this criterion:</p><ul class="list-custom"><li class="icon-check text-success"><strong>Type requirements are met:</strong> You must adhere to the specification of the key and value type given above. For example, many solutions we receive use operations other than those that are explicitly stated in the task description. We have to reject many solutions because they assume that <var>V</var> is default-constructible, e.g., by using std::map::operator[].</li><li class="icon-check text-success"><strong>Correctness:</strong> Your program should produce a working <code>interval_map</code> with the behavior described above. In particular, pay attention to the validity of iterators. It is illegal to dereference end iterators. Consider using a checking STL implementation such as the one shipped with Visual C++ or GCC. Many solutions we receive do not create the data structure that was asked for, e.g., some interval ends up being associated with the wrong value. Others contain a code path that will eventually dereference an invalid or end iterator.</li><li class="icon-check text-success"><strong>Canonicity:</strong> The representation in <code>m_map</code> must be canonical. Some solutions we receive create consecutive map entries containing the same value, or repeat the value of m_valBegin at the beginning of the map.</li><li class="icon-error alert-danger"><p><strong>Running time:</strong> Imagine your implementation is part of a library, so it should be big-O optimal. In addition:</p><ul><li>Do not make big-O more operations on <var>K</var> and <var>V</var> than necessary because you do not know how fast operations on <var>K</var>/<var>V</var> are; remember that constructions, destructions and assignments are operations as well.</li><li>Do not make more than one operation of amortized O(log <var>N</var>), in contrast to O(1), running time, where <var>N</var> is the number of elements in <code>m_map</code>. Overloads of std::map::insert&sol;emplace&sol;delete that need to find an element position for a given key, have a running time of amortized O(log <var>N</var>). Overloads of std::map::insert&sol;emplace&sol;delete that take an iterator to the position of the inserted&sol;deleted element,have a running time of amortized O(1), if the iterator points to the correct position.</li><li>Otherwise favor simplicity over minor speed improvements.</li></ul></li></ul><p>We regret that we cannot provide you with information specific to your solution, or with a correct version of the algorithm, because if we did, then we could no longer use this challenge for our interview process. We sincerely hope for your understanding on this matter.</p><p>Since this was your final submission, we have decided not to offer you an interview.</p><p>We want to thank you for your interest in the C++ developer position at think-cell and for the time and effort you have put into taking our programing test. We know that C++ developers are a scarce resource and that you have a choice of companies you can work for. For this reason we highly value your application.</p><p>Arno, our CTO, and the HR Team want to thank you for your time and interest in our company, and wish you the very best in your future career.<p>
																																																															
											 							</div>
		</div>
	</form>
</div>

</main><div id="footer" class="darkgray-inverse"><div class="container-fluid"><div class="row"><div class="col-auto mr-auto">&copy;2002-2024 think-cell Software GmbH</div><div class="col-auto"><a href="https://server.think-cell.com/portal/en/redirect.srf?url=https%3A%2F%2Fwww.think-cell.com%2Fen%2Fprivacy">Privacy Policy</a>&emsp;<a href="https://server.think-cell.com/portal/en/redirect.srf?url=https%3A%2F%2Fwww.think-cell.com%2Fen%2Fcompany%2Flegalnotice">Contact information and legal notice</a></div></div></div></div><script>var _paq=_paq || [];_paq.push(["setCustomUrl", "https://server.think-cell.com/portal/en/recruitingtest.srf"]);_paq.push(["setCustomDimension", customDimensionId=1, customDimensionValue="200"]);_paq.push(["setCustomDimension", customDimensionId=2, customDimensionValue="false"]);_paq.push(["setCustomVariable", 1, "UserId", "31821787-C51A-451B-99C0-E392A539F686", "visit"]);</script><script>
  var _paq = _paq || []
  _paq.push(['setDoNotTrack', true])
  _paq.push(['setCookieDomain', '*.think-cell.com'])
  _paq.push(['setDomains', ['*.think-cell.com']])
  function HasCookie(name) {
    return !!RegExp('(^|;)[ ]*' + name + '=([^;]*)').exec(document.cookie)
  }
  if(!HasCookie('_pk_id.1.b108')) {
    _paq.push([function () { this.requireCookieConsent() }])
  }
  _paq.push(['trackPageView'])
  _paq.push(['enableLinkTracking'])
  ;(function () {
    var u = 'https://matomo.think-cell.com/'
    _paq.push(['setTrackerUrl', u + 'piwik.php'])
    _paq.push(['setSiteId', 1])
    var d = document,
      g = d.createElement('script'),
      s = d.getElementsByTagName('script')[0]
    g.type = 'text/javascript'
    g.defer = true
    g.async = true
    g.src = u + 'piwik.js'
    s.parentNode.insertBefore(g, s)
  })()

</script>
<script src="https://www.think-cell.com/js/tracking.js"></script>
<noscript>
  <p><img src="https://matomo.think-cell.com/piwik.php?idsite=1" style="border: 0" alt="" /></p>
</noscript>		<script src="https://www.think-cell.com/js/site.js?id=8ab19c5a7589ac9393cf949a0132e1e2"></script>
	</body>
</html>